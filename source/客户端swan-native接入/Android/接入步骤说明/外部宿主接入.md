# 小程序SDK的仓库地址
	https://github.com/swan-team/swan-android（注：私有仓库）
# 小程序结构说明
+ 小程序由3部分构成：客户端SDK(SwanNative)、前端JS SDK(SwanJS)、后端服务(Server)。
+ 接入SDK需要同时处理好这个3个部分。
+ SwanNative：主要用于对外提供系统级能力，如视频播放、直播、弹框、登录等等。
+ SwanJS：预置在客户端SDK内部，可以通过网络自动更新，运行于SwanNative的WebView里，提供页面和组件的展示和处理逻辑。
+ Server：SwanJs和第三方开发的小程序包需要通过Server下发，登录和授权认证也需要走Server。
 	
# 各个库的说明(从上到下)
+ demo ： 小程序的demo示例，具有基本的运行小程序的能力。包含接入小程序需要做的初始化工作 & 小程序能力接口的实现（目前是空实现）。
+ lib-browser-base ： 小程序内部浏览器框架的分类，目前为了和手百保持一致，直接扣取的代码，第三方不用关心，直接集成即可。
+ lib-event-bus ： 小程序内部使用到了RxJava和对RxJava封装的RxBus，这个库作为基础提供。
+ lib-multiprocess ： 如果使用手百的UBC（天幕）打点统计系统（下边的lib-ng-aiapps-ubc lib），才需要这个库，进行跨进程打点用的（如果不使用统计能力，可以不需要这个lib）。
+ lib-swan-core ： 小程序的core代码，这个是小程序的主lib，其他lib都是为他服务的。
+ lib-swan-mario：小程序内部使用的JS解析器是采用的V8引擎，此lib提供V8引擎。
+ lib-swan-pms：从Server拉取SwanJs和小程序包的下载能力，直接接入手百Server后台，直接集成即可。
+ lib-swan-menu：小程序内部使用的菜单View。
+ lib-swan-net：对okhttp的封装，更方便使用的网络库。
+ lib-swan-ubc ： 小程序本身自带各种统计打点，外部对接Case默认不提供打点能力，属于可选（可选择打点到百度，也可选择打点到指定的地址，也可以选择不要打点功能，不打点不需要集成此lib）。
+ lib-process-ipc：由于小程序是运行在独立进程的，需要多进程间通信，这个lib是用来多进程通信的。
+ lib-protobuf：lib-swan-ubc库使用的打点统计格式，规定了统计的形式采用protobuf形式存储。
+ lib-runtime ： 小程序SDK的运行时环境，需要在app启动的时候调用，详情参考 *初始化说明*
+ lib-slide ： 小程序内部使用到了侧滑返回页面的能力，这个库提供侧滑功能。
+ lib-support-empty：由于历史原因，一些代码还无法立即全部去除，为了保证编译通过，引入空实现。和业务无关，不需要关心。
+ lib-united-scheme-core：小程序内部的通信是使用Scheme协议完成的，这个是小程序内部的通信框架。
+ lib-swan-v4-fragment：小程序使用到了fragment，这里使用了定制的fragment，而不是用系统的v4包提供的。
+ lib-websocket：小程序里的webSocket能力。
+ local-maven：搭建的本地maven仓库，用于存放gralde插件**后续放到中央仓库**

# 需要使用到的外部库
+ com.squareup.okhttp3:okhttp:3.11.0 使用到了 okhttp3.11.0 
+ com.airbnb.android:lottie:2.3.1 使用到了lottie2.3.1
+ io.reactivex:rxjava:1.2.3 使用到了rxjava 1.2.3
+ io.reactivex:rxandroid:1.2.0 使用到了rxandroid 1.2.0
+ com.android.support:support-v4:26.1.0
+ com.android.support:appcompat-v7:26.1.0
+ com.android.support:recyclerview-v7:26.1.0
+ com.android.support:support-annotations:26.1.0
+ com.facebook.fresco:fresco:1.2.0
+ com.baidu.pyramid:pyramid-annotation:0.1.2 ：小程序的金字塔注入插件。
+ com.baidu.pyramid.di：小程序的金字塔注入插件（gradle插件，编译时进行代码注入用的）配合pyramid-annotation使用
+ 具体配置参考settings.gradle

# 使用到的gradle插件
+ apply plugin: 'com.baidu.pyramid.di'
+ 具体配置参考demo工程build.gradle 和 根目录下的build.gradle
+ 插件目前位于工程的local-maven文件夹下

# 接入步骤
+ 0.将工程中的除了demo之外的所有lib，复制到自己的工程（当然，可以自己打包成aar放到工程中）
+ 1.配置工程，参考根目录的settigns.gradle build.gradle demo/build.gradle
+ 2.在app工程的的build.gradle文件中，需要使用apply plugin: 'com.baidu.pyramid.di'插件（本质是gradle打包过程的Transform机制）
+ 3.在app的application类中添加以下初始化代码（参考demo工程）

```
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        // 必须在attachBaseContext中初始化
        AiAppsInitHelper.initContext(this);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        // 必须在attachBaseContext之后初始化
        AiAppsInitHelper.initModules(this);
    }
```
+ 4.实现lib-swan-core/com.baidu.swan.apps.ioc.interfaces包下的所有接口和抽象类（demo在com.baidu.swan.apps.demo.aiapps.impl包下，可以参考实现），结合 **接口文档实现**
+ 5.<font color=red>外部宿主无法直接使用百度的Server系统，需要按照Server文档协议，实现自己的Server：</font>
	- 目前小程序的账号体系需要依赖宿主的账号，这部分需要Server参与，参考[server端接入](../../../server端接入)
	- 小程序的授权体系，需要宿主Server自己实现，参考[server端接入](../../../server端接入)
	- 其他如：选择发票、选择收货地址、推送、支付、GetSwanId 也需要Server参与，参考[server端接入](../../../server端接入)
+ 注：整个小程序一共有2种网络请求：
	- 1.是宿主本身业务使用的，直接访问到宿主Server，小程序开发者不可见，无法使用，会携带UA和Cookies。
	- 2.是专门给小程序开发使用的，比如上传个文件，打开个页面等，开发者可以配置网络的各种属性，这个请求只会携带UA。
+ 6.如果希望在小程序里添加自己的扩展能力，需要是用extersion机制，详情参考FE的文档，接口人 **@侯禹**

# 启动一个小程序
+ 一共有2种打开方式：
    - 1.是一个scheme码：xxxx://swan/TZzPY8qVvX97uzIH4L2SnY0g (xxxx是接入步骤5中注册的scheme协议头，TZzPY8qVvX97uzIH4L2SnY0g是要打开小程序的id)
    - 2.是一个url链接（手百提供的二维码一般都是这种url形式）：如https://smartapp.baidu.com/mappconsole/api/packagescheme?appKey=iNBe6qH2CklDbCNzwSAzqLpboAgB58Hn&packageId=51102，这种实际上是需要从服务器获取一个可以打开的scheme，和上一种形式一致。
+ 这两种方式都可以使用SwanAppLaunchHelper#launch方法打开，内部进行了统一，如逻辑不满足可自定义。
+ 小程序的入口就在SwanAppLaunchHelper#launch方法，参数就是上部所讲的2中url形式。

# 混淆规则
+ debug包下不需要做任何混淆。
+ release包的混淆规则参考demo工程的demo/proguard-rules.pro文件。

# 其他注意事项。
+ 启动方式是一个http url链接的，默认Server 会302重定向到一个scheme而不是返回一个包含scheme的json对象，一般webView可以帮助处理302到Scheme的情况，但是如果直接使用网络库请求，网路库一般不识别scheme形式的302，此时需要在请求中添加Swan-Accept:swan/json 字段，强制Server返回json对象，scheme包含在json中，取出来自己处理scheme即可。
+ 由于小程序是多进程架构，在跨进程启动Activity的时候，务必使用小程序的context，同时activty不可以是singleTask方式，否则会有页面栈问题（从小程序进入一个activity，返回之后发现回到主进程了）。
+ 如果使用了手百的UBC打点框架，数据会打到手百的Server，后台通过hostName区分，需要到UBC的仓库查看具体的打点信息。
+ 目前小游戏的代码和小程序的代码没做解耦，还是放在一起提供，只是小游戏的还不能使用而已，如不需要可自行删除小游戏代码（lib-swan-core/src/main/java/com/baidu/swan/games）目录下。

